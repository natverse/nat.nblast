[{"path":"https://natverse.org/nat.nblast/SUPPORT.html","id":null,"dir":"","previous_headings":"","what":"Getting help with nat.nblast","title":"Getting help with nat.nblast","text":"Thanks using nat.nblast. ’re sorry ’re trouble, don’t worry, ’re help! get help quickly possible, please read following:","code":""},{"path":"https://natverse.org/nat.nblast/SUPPORT.html","id":"search","dir":"","previous_headings":"","what":"Search","title":"Getting help with nat.nblast","text":"first thing see anyone problem : Search nat-user google group. Search GitHub issues nat.nblast package. Search GitHub issues across whole natverse case problem related package. can add terms search search box top left page. solves problem, great!","code":""},{"path":"https://natverse.org/nat.nblast/SUPPORT.html","id":"known-problems","dir":"","previous_headings":"","what":"Known Problems","title":"Getting help with nat.nblast","text":"need help known problem: found relevant thread nat-user google group: please reply . found GitHub issue: please reply details just like (click emoji button add thumbs ) let us know ’re trouble . ’ll need GitHub login . ’re sure: ask new question nat-user google group linking found.","code":""},{"path":"https://natverse.org/nat.nblast/SUPPORT.html","id":"new-problems","dir":"","previous_headings":"","what":"New Problems","title":"Getting help with nat.nblast","text":"looks like new problem : just question: please ask nat-user google group. need report new bug: please file issue. ’re sure: please just ask nat-user google group! problem bug feature request, can easily return report - may able point existing report workaround.","code":""},{"path":"https://natverse.org/nat.nblast/SUPPORT.html","id":"good-questions-and-bug-reports","dir":"","previous_headings":"","what":"Good Questions and Bug Reports","title":"Getting help with nat.nblast","text":"specific Include code triggered problem possible, make minimal reproducible example (reprex) much easier us help can run reprex machine without data. might want use sample data nat package help, refer publicly available data online. can use reprex package help prepare reprex. Read Get help! section tidyverse site information. Thanks help!","code":""},{"path":"https://natverse.org/nat.nblast/articles/NBLAST-Clustering.html","id":"startup","dir":"Articles","previous_headings":"","what":"Startup","title":"NBLAST Clustering","text":"Install package required Load package set knitr / 3D snapshot figures","code":"install.packages('nat.nblast', dependencies = TRUE) library(nat.nblast) ## Warning in rgl.init(initValue, onlyNULL): RGL: unable to open X11 display ## Warning: 'rgl.init' failed, will use the null device. ## See '?rgl.useNULL' for ways to avoid this warning. rgl::setupKnitr()"},{"path":[]},{"path":"https://natverse.org/nat.nblast/articles/NBLAST-Clustering.html","id":"all-by-all-scores","dir":"Articles","previous_headings":"Clustering with NBLAST scores","what":"All by all scores","title":"NBLAST Clustering","text":"First create 20 x 20 NBLAST score matrix 20 Kenyon cells included nat package","code":"library(nat) kcscores <- nblast_allbyall(kcs20)"},{"path":"https://natverse.org/nat.nblast/articles/NBLAST-Clustering.html","id":"clustering","dir":"Articles","previous_headings":"Clustering with NBLAST scores","what":"Clustering","title":"NBLAST Clustering","text":"Hierarchically cluster Kenyon scores divide clustering 3 groups Plot dendrogram clustering, leaves labelled true neuron type","code":"hckcs <- nhclust(scoremat=kcscores) ## The \"ward\" method has been renamed to \"ward.D\"; note new \"ward.D2\" library(dendroextras) dkcs <- colour_clusters(hckcs, k=3) labels(dkcs) <- with(kcs20[labels(dkcs)], type) par(cex=.7) # so labels are legible plot(dkcs)"},{"path":"https://natverse.org/nat.nblast/articles/NBLAST-Clustering.html","id":"d-plot","dir":"Articles","previous_headings":"Clustering with NBLAST scores","what":"3D plot","title":"NBLAST Clustering","text":"can create interactive 3D plots using rgl package different subgroups neurons coloured according calculated clustering.","code":"plot3d(hckcs, k=3, db=kcs20, soma=T) par3d(userMatrix=diag(c(1,-1,-1,1), 4)) plot3d(MBL.surf, alpha=.1)"},{"path":"https://natverse.org/nat.nblast/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Gregory Jefferis. Author, maintainer. James Manton. Author.","code":""},{"path":"https://natverse.org/nat.nblast/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jefferis G, Manton J (2025). nat.nblast: NeuroAnatomy Toolbox ('nat') Extension Assessing Neuron Similarity Clustering. R package version 1.6.8, https://natverse.org/nat.nblast/.","code":"@Manual{,   title = {nat.nblast: NeuroAnatomy Toolbox ('nat') Extension for Assessing Neuron Similarity and Clustering},   author = {Gregory Jefferis and James Manton},   year = {2025},   note = {R package version 1.6.8},   url = {https://natverse.org/nat.nblast/}, }"},{"path":"https://natverse.org/nat.nblast/index.html","id":"natnblast-","dir":"","previous_headings":"","what":"NeuroAnatomy Toolbox (nat) Extension for Assessing Neuron Similarity and Clustering","title":"NeuroAnatomy Toolbox (nat) Extension for Assessing Neuron Similarity and Clustering","text":"nat.nblast part NeuroAnatomy Toolbox suite R packages.","code":""},{"path":"https://natverse.org/nat.nblast/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"NeuroAnatomy Toolbox (nat) Extension for Assessing Neuron Similarity and Clustering","text":"impatient …","code":"# install if (!require(\"devtools\")) install.packages(\"devtools\") devtools::install_github(c(\"natverse/nat\", \"natverse/nat.nblast\"))  # use library(nat.nblast)  # run examples for search example(\"nblast\")  # run examples for clustering example(\"nhclust\")  # get overview help for package ?nat.nblast # help for functions ?nblast ?nhclust  # run tests library(testthat) test_package(\"nat.nblast\")"},{"path":"https://natverse.org/nat.nblast/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"NeuroAnatomy Toolbox (nat) Extension for Assessing Neuron Similarity and Clustering","text":"R package implements NBLAST neuron similarity algorithm described Costa M, Manton JD, Ostrovsky AD, Prohaska S, Jefferis GS. NBLAST: Rapid, Sensitive Comparison Neuronal Structure Construction Neuron Family Databases.Neuron. 2016 Jul 20;91(2):293-311. doi: 10.1016/j.neuron.2016.06.012. addition basic pairwise comparison, package implements search databases neurons. also support x comparison group neurons. can produce distance matrix suitable hierarchical clustering, also implemented package. tools designed addon NeuroAnatomy Toolbox (nat) R package, installed dependency. probably find following online documentation helpful: https://natverse.org/nat.nblast/ - Online documentation R package https://jefferislab.org/si/nblast/ - Overview NBLAST algorithm online tools","code":""},{"path":"https://natverse.org/nat.nblast/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"NeuroAnatomy Toolbox (nat) Extension for Assessing Neuron Similarity and Clustering","text":"package released CRAN (since v1.5), generally recommend installing development version GitHub, especially notice bug.","code":""},{"path":"https://natverse.org/nat.nblast/index.html","id":"cran-release","dir":"","previous_headings":"Installation","what":"CRAN release","title":"NeuroAnatomy Toolbox (nat) Extension for Assessing Neuron Similarity and Clustering","text":"","code":"install.packages(\"nat.nblast\")"},{"path":"https://natverse.org/nat.nblast/index.html","id":"development-version","dir":"","previous_headings":"Installation","what":"Development version","title":"NeuroAnatomy Toolbox (nat) Extension for Assessing Neuron Similarity and Clustering","text":"Use remotes install development version: Note also update nat package latest development version github. Windows users need Rtools install way.","code":"# install devtools if required if (!require(\"remotes\")) install.packages(\"remotes\") # then nat.nblast remotes::install_github(\"natverse/nat.nblast\")"},{"path":"https://natverse.org/nat.nblast/reference/NeuriteBlast.html","id":null,"dir":"Reference","previous_headings":"","what":"Produce similarity score for neuron morphologies — NeuriteBlast","title":"Produce similarity score for neuron morphologies — NeuriteBlast","text":"low-level entry point NBLAST algorithm compares morphology neuron list neurons. use cases, one probably wish use nblast instead.","code":""},{"path":"https://natverse.org/nat.nblast/reference/NeuriteBlast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Produce similarity score for neuron morphologies — NeuriteBlast","text":"","code":"NeuriteBlast(   query,   target,   targetBinds = NULL,   normalised = FALSE,   OmitFailures = NA,   simplify = TRUE,   ... )"},{"path":"https://natverse.org/nat.nblast/reference/NeuriteBlast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Produce similarity score for neuron morphologies — NeuriteBlast","text":"query either single query neuron neuronlist target neuronlist compare neuron . targetBinds numeric indices names subset target. normalised whether divide scores self-match score query OmitFailures Whether omit neurons FUN gives error. default value (NA) result nblast stopping error message moment error. values, see details. simplify whether simplify scores list vector. TRUE default. time might want set false collecting something simple scores search function. See simplify2array details. ... extra arguments pass distance function.","code":""},{"path":"https://natverse.org/nat.nblast/reference/NeuriteBlast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Produce similarity score for neuron morphologies — NeuriteBlast","text":"Named list similarity scores.","code":""},{"path":"https://natverse.org/nat.nblast/reference/NeuriteBlast.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Produce similarity score for neuron morphologies — NeuriteBlast","text":"detailed description OmitFailures argument, see   details section nblast.","code":""},{"path":[]},{"path":"https://natverse.org/nat.nblast/reference/WeightedNNBasedLinesetMatching.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute point & tangent vector similarity score between two linesets — WeightedNNBasedLinesetMatching","title":"Compute point & tangent vector similarity score between two linesets — WeightedNNBasedLinesetMatching","text":"WeightedNNBasedLinesetMatching low level function   called nblast. end users usually   need call directly. allow results NBLAST comparison   inspected detail (see examples).","code":""},{"path":"https://natverse.org/nat.nblast/reference/WeightedNNBasedLinesetMatching.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute point & tangent vector similarity score between two linesets — WeightedNNBasedLinesetMatching","text":"","code":"WeightedNNBasedLinesetMatching(target, query, ...)  # S3 method for class 'dotprops' WeightedNNBasedLinesetMatching(target, query, UseAlpha = FALSE, ...)  # S3 method for class 'neuron' WeightedNNBasedLinesetMatching(   target,   query,   UseAlpha = FALSE,   OnlyClosestPoints = FALSE,   ... )"},{"path":"https://natverse.org/nat.nblast/reference/WeightedNNBasedLinesetMatching.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute point & tangent vector similarity score between two linesets — WeightedNNBasedLinesetMatching","text":"target, query dotprops neuron objects compare (must class) ... extra arguments pass distance function. UseAlpha Whether scale dot product tangent vectors (default=F) OnlyClosestPoints Whether restrict searches closest points target (default FALSE, implemented dotprops).","code":""},{"path":"https://natverse.org/nat.nblast/reference/WeightedNNBasedLinesetMatching.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute point & tangent vector similarity score between two linesets — WeightedNNBasedLinesetMatching","text":"Value NNDistFun passed   WeightedNNBasedLinesetMatching","code":""},{"path":"https://natverse.org/nat.nblast/reference/WeightedNNBasedLinesetMatching.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute point & tangent vector similarity score between two linesets — WeightedNNBasedLinesetMatching","text":"WeightedNNBasedLinesetMatching work 2 objects   class dotprops neuron. code calculate scores   directly neuron objects gives broadly comparable scores   dotprops objects, lightly tested. Furthermore   objects dotprops form used construction   scoring matrices distributed package. therefore recommended   convert neuron objects dotprops objects using   dotprops function. UseAlpha determines whether alpha values   (eig1-eig2)/sum(eig1:3) passed   WeightedNNBasedLinesetMatching. used scale dot   products direction vectors nearest neighbour pairs.","code":""},{"path":[]},{"path":"https://natverse.org/nat.nblast/reference/WeightedNNBasedLinesetMatching.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute point & tangent vector similarity score between two linesets — WeightedNNBasedLinesetMatching","text":"","code":"# Retrieve per segment distances / absolute dot products segvals=WeightedNNBasedLinesetMatching(kcs20[[1]], kcs20[[2]], NNDistFun=list) names(segvals)=c(\"dist\", \"adotprod\") pairs(segvals)"},{"path":"https://natverse.org/nat.nblast/reference/calc_dists_dotprods.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate distances and dot products between two sets of neurons — calc_dists_dotprods","title":"Calculate distances and dot products between two sets of neurons — calc_dists_dotprods","text":"Calculate distances dot products two sets neurons","code":""},{"path":"https://natverse.org/nat.nblast/reference/calc_dists_dotprods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate distances and dot products between two sets of neurons — calc_dists_dotprods","text":"","code":"calc_dists_dotprods(   query_neurons,   target_neurons,   subset = NULL,   ignoreSelf = TRUE,   ... )"},{"path":"https://natverse.org/nat.nblast/reference/calc_dists_dotprods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate distances and dot products between two sets of neurons — calc_dists_dotprods","text":"query_neurons neuronlist use calculating distances dot products. target_neurons neuronlist use calculating distances dot products. subset data.frame specifying neurons query_neurons target_neurons compared, columns specifying query target neurons name, one row pair. unspecified, defaults --comparison. ignoreSelf Boolean indicating whether ignore comparisons neuron (default TRUE). ... extra arguments pass NeuriteBlast.","code":""},{"path":"https://natverse.org/nat.nblast/reference/calc_dists_dotprods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate distances and dot products between two sets of neurons — calc_dists_dotprods","text":"list, one element pair neurons 2 column   data.frame containing one column distances another absolute dot   products.","code":""},{"path":"https://natverse.org/nat.nblast/reference/calc_dists_dotprods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate distances and dot products between two sets of neurons — calc_dists_dotprods","text":"Distances dot products raw inputs constructing   scoring matrices NBLAST search algorithm.","code":""},{"path":"https://natverse.org/nat.nblast/reference/calc_prob_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate probability matrix from distances and dot products between neuron segments — calc_prob_mat","title":"Calculate probability matrix from distances and dot products between neuron segments — calc_prob_mat","text":"Calculate probability matrix distances dot products neuron segments","code":""},{"path":"https://natverse.org/nat.nblast/reference/calc_prob_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate probability matrix from distances and dot products between neuron segments — calc_prob_mat","text":"","code":"calc_prob_mat(   nndists,   dotprods,   distbreaks,   dotprodbreaks = seq(0, 1, by = 0.1),   ReturnCounts = FALSE )"},{"path":"https://natverse.org/nat.nblast/reference/calc_prob_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate probability matrix from distances and dot products between neuron segments — calc_prob_mat","text":"nndists list nearest-neighbour distances list nearest-neighbour distances dot products. dotprods list dot products. distbreaks vector specifying breaks distances probability matrix. dotprodbreaks vector specifying breaks dot products probability matrix. ReturnCounts Boolean indicating counts returned instead default probabilities.","code":""},{"path":"https://natverse.org/nat.nblast/reference/calc_prob_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate probability matrix from distances and dot products between neuron segments — calc_prob_mat","text":"matrix columns specified dotprodbreaks rows   specified distbreaks, containing probabilities (default   value ReturnCounts=TRUE) counts (ReturnCounts=TRUE)   finding neuron segments given distance dot product.","code":""},{"path":"https://natverse.org/nat.nblast/reference/calc_score_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate scoring matrix from probability matrices for matching and non-matching sets of neurons — calc_score_matrix","title":"Calculate scoring matrix from probability matrices for matching and non-matching sets of neurons — calc_score_matrix","text":"Calculate scoring matrix probability matrices matching non-matching sets neurons","code":""},{"path":"https://natverse.org/nat.nblast/reference/calc_score_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate scoring matrix from probability matrices for matching and non-matching sets of neurons — calc_score_matrix","text":"","code":"calc_score_matrix(matchmat, randmat, logbase = 2, epsilon = 1e-06)"},{"path":"https://natverse.org/nat.nblast/reference/calc_score_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate scoring matrix from probability matrices for matching and non-matching sets of neurons — calc_score_matrix","text":"matchmat probability matrix given considering 'matching' neurons. randmat probability matrix given considering 'non-matching' 'random' neurons. logbase base logarithm taken produce final scores. epsilon pseudocount prevent division zero constructing log odds ratio probability matrix.","code":""},{"path":"https://natverse.org/nat.nblast/reference/calc_score_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate scoring matrix from probability matrices for matching and non-matching sets of neurons — calc_score_matrix","text":"matrix class=c(\"scoringmatrix\", \"table\"),   columns specified dotprodbreaks rows specified   distbreaks, containing scores neuron segments given   distance dot product.","code":""},{"path":"https://natverse.org/nat.nblast/reference/create_scoringmatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a scoring matrix given matching and non-matching sets of neurons — create_scoringmatrix","title":"Create a scoring matrix given matching and non-matching sets of neurons — create_scoringmatrix","text":"Calculate scoring matrix embodying logarithm odds   matching pair neurite segments come structurally related   rather random pair neurons. function embodies sensible default   behaviours recommended end users. control available   using individual functions listed See Also.","code":""},{"path":"https://natverse.org/nat.nblast/reference/create_scoringmatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a scoring matrix given matching and non-matching sets of neurons — create_scoringmatrix","text":"","code":"create_scoringmatrix(   matching_neurons,   nonmatching_neurons,   matching_subset = NULL,   non_matching_subset = NULL,   ignoreSelf = TRUE,   distbreaks,   dotprodbreaks = seq(0, 1, by = 0.1),   logbase = 2,   epsilon = 1e-06,   ... )"},{"path":"https://natverse.org/nat.nblast/reference/create_scoringmatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a scoring matrix given matching and non-matching sets of neurons — create_scoringmatrix","text":"matching_neurons neuronlist matching neurons. nonmatching_neurons neuronlist non-matching neurons. matching_subset, non_matching_subset data.frames indicating pairs neurons two input neuron lists used generate matching null distributions. See details default behaviour NULL. ignoreSelf Boolean indicating whether ignore comparisons neuron (default TRUE). distbreaks vector specifying breaks distances probability matrix. dotprodbreaks vector specifying breaks dot products probability matrix. logbase base logarithm taken produce final scores. epsilon pseudocount prevent division zero constructing log odds ratio probability matrix. ... extra arguments pass NeuriteBlast options call mlply call actually iterates neuron pairs.","code":""},{"path":"https://natverse.org/nat.nblast/reference/create_scoringmatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a scoring matrix given matching and non-matching sets of neurons — create_scoringmatrix","text":"matrix columns specified dotprodbreaks rows   specified distbreaks, containing log odd scores neuron   segments given distance dot product.","code":""},{"path":"https://natverse.org/nat.nblast/reference/create_scoringmatrix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a scoring matrix given matching and non-matching sets of neurons — create_scoringmatrix","text":"default create_scoringmatrix use neurons   matching_neurons create matching distribution.   appropriate neurons single type. wish   use multiple types neurons need specify   matching_subset indicate pairs neurons   type. default create_scoringmatrix use random set pairs   non_matching_neurons create null distribution. number   random pairs equal number matching pairs defined   matching_neurons appropriate non_matching_neurons   contains large collection neurons different types. may wish   set random seed using set.seed want ensure   exactly (pseudo-)random pairs neurons used subsequent   calls.","code":""},{"path":[]},{"path":"https://natverse.org/nat.nblast/reference/create_scoringmatrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a scoring matrix given matching and non-matching sets of neurons — create_scoringmatrix","text":"3D plot","code":"# \\donttest{ # calculate scoring matrix # bring in some mushroom body neurons library(nat) data(kcs20) # convert the (connected) tracings into dotprops (point and vector) # representation, resampling at 1 micron intervals along neuron fctraces20.dps=dotprops(fctraces20, resample=1) # we will use both all kcs vs all fctraces20 and fctraces20 vs fctraces20 # as random_pairs to make the null distribution random_pairs=rbind(neuron_pairs(fctraces20), neuron_pairs(nat::kcs20, fctraces20)) # you can add .progress='natprogress' if this looks like taking a while smat=create_scoringmatrix(kcs20, c(kcs20, fctraces20.dps),                           non_matching_subset=random_pairs)  # now plot the scoring matrix distbreaks=attr(smat,'distbreaks') distbreaks=distbreaks[-length(distbreaks)] dotprodbreaks=attr(smat,'dotprodbreaks')[-1] # Create a function interpolating colors in the range of specified colors jet.colors <- colorRampPalette( c(\"blue\", \"green\", \"yellow\", \"red\") ) # 2d filled contour plot of scoring matrix. Notice that the there is a region # at small distances and large abs dot product with the highest log odds ratio # i.e. most indicative of a match rather than non-match filled.contour(x=distbreaks, y=dotprodbreaks, z=smat, col=jet.colors(20),   main='smat: log odds ratio', xlab='distance /um', ylab='abs dot product')   # 3d perspective plot of the scoring matrix persp3d(x=distbreaks, y=dotprodbreaks, z=smat, col=jet.colors(20)[cut(smat,20)], xlab='distance /um', ylab='abs dot product', zlab='log odds ratio') 3D plot  {\"x\":{\"material\":{\"color\":\"#000000\",\"alpha\":1,\"lit\":true,\"ambient\":\"#000000\",\"specular\":\"#FFFFFF\",\"emission\":\"#000000\",\"shininess\":50,\"smooth\":true,\"front\":\"filled\",\"back\":\"filled\",\"size\":3,\"lwd\":1,\"fog\":true,\"point_antialias\":false,\"line_antialias\":false,\"texture\":null,\"textype\":\"rgb\",\"texmode\":\"modulate\",\"texmipmap\":false,\"texminfilter\":\"linear\",\"texmagfilter\":\"linear\",\"texenvmap\":false,\"depth_mask\":true,\"depth_test\":\"less\",\"isTransparent\":false,\"polygon_offset\":[0,0],\"margin\":\"\",\"floating\":false,\"tag\":\"\",\"blend\":[\"src_alpha\",\"one_minus_src_alpha\"]},\"rootSubscene\":1,\"objects\":{\"8\":{\"id\":8,\"type\":\"surface\",\"material\":{},\"vertices\":\"0\",\"colors\":\"2\",\"dim\":[[21,10]],\"centers\":\"3\",\"normals\":\"1\",\"ignoreExtent\":false,\"flipped\":true,\"flags\":32771},\"10\":{\"id\":10,\"type\":\"text\",\"material\":{\"lit\":false,\"margin\":0,\"floating\":true,\"edge\":[0,1,1]},\"vertices\":\"4\",\"colors\":\"5\",\"texts\":[[\"distance /um\"]],\"cex\":[[1]],\"adj\":[[0.5,0.5,0.5]],\"centers\":\"6\",\"family\":[[\"sans\"]],\"font\":[[1]],\"ignoreExtent\":true,\"flags\":33808},\"11\":{\"id\":11,\"type\":\"text\",\"material\":{\"lit\":false,\"margin\":1,\"floating\":true,\"edge\":[1,1,1]},\"vertices\":\"7\",\"colors\":\"8\",\"texts\":[[\"abs dot product\"]],\"cex\":[[1]],\"adj\":[[0.5,0.5,0.5]],\"centers\":\"9\",\"family\":[[\"sans\"]],\"font\":[[1]],\"ignoreExtent\":true,\"flags\":33808},\"12\":{\"id\":12,\"type\":\"text\",\"material\":{\"lit\":false,\"margin\":2,\"floating\":true,\"edge\":[1,1,1]},\"vertices\":\"10\",\"colors\":\"11\",\"texts\":[[\"log odds ratio\"]],\"cex\":[[1]],\"adj\":[[0.5,0.5,0.5]],\"centers\":\"12\",\"family\":[[\"sans\"]],\"font\":[[1]],\"ignoreExtent\":true,\"flags\":33808},\"5\":{\"id\":5,\"type\":\"light\",\"vertices\":[[0,0,1]],\"colors\":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],\"viewpoint\":true,\"finite\":false},\"7\":{\"id\":7,\"type\":\"background\",\"material\":{\"lit\":false,\"back\":\"lines\"},\"colors\":\"13\",\"centers\":\"14\",\"sphere\":false,\"fogtype\":\"none\",\"fogscale\":1,\"flags\":32768},\"9\":{\"id\":9,\"type\":\"bboxdeco\",\"material\":{\"front\":\"lines\",\"back\":\"lines\"},\"vertices\":\"15\",\"colors\":\"16\",\"axes\":{\"mode\":[\"pretty\",\"pretty\",\"pretty\"],\"step\":[10,0.2000000029802322,2],\"nticks\":[5,5,5],\"marklen\":[15,15,15],\"expand\":[1.029999971389771,1.029999971389771,1.029999971389771]},\"draw_front\":true,\"flags\":32769},\"1\":{\"id\":1,\"type\":\"subscene\",\"par3d\":{\"antialias\":8,\"FOV\":30,\"ignoreExtent\":false,\"listeners\":1,\"mouseMode\":{\"none\":\"none\",\"left\":\"trackball\",\"right\":\"zoom\",\"middle\":\"fov\",\"wheel\":\"pull\"},\"observer\":[0,0,100.7774124145508],\"modelMatrix\":[[0.594437837600708,0,0,-11.88875675201416],[0,9.03598690032959,2.288785457611084,-5.083317279815674],[0,-24.82616996765137,0.8330498337745667,-87.16433715820312],[0,0,0,1]],\"projMatrix\":[[3.732050895690918,0,0,0],[0,3.732050895690918,0,0],[0,0,-3.863703489303589,-363.2909240722656],[0,0,-1,0]],\"skipRedraw\":false,\"userMatrix\":[[1,0,0,0],[0,0.3420201433256682,0.9396926207859085,0],[0,-0.9396926207859085,0.3420201433256682,0],[0,0,0,1]],\"userProjection\":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],\"scale\":[0.594437837600708,26.41945838928223,2.435674667358398],\"viewport\":{\"x\":0,\"y\":0,\"width\":1,\"height\":1},\"zoom\":1,\"bbox\":[0,40,0.1000000014901161,1,-4.831493377685547,4.930694103240967],\"windowRect\":[0,0,256,256],\"family\":\"sans\",\"font\":1,\"cex\":1,\"useFreeType\":true,\"fontname\":\"NULL\",\"maxClipPlanes\":2147483647,\"glVersion\":\"NA\",\"activeSubscene\":0},\"embeddings\":{\"viewport\":\"replace\",\"projection\":\"replace\",\"model\":\"replace\",\"mouse\":\"replace\"},\"objects\":[7,9,8,10,11,12,5],\"subscenes\":[],\"flags\":34067}},\"crosstalk\":{\"key\":[],\"group\":[],\"id\":[],\"options\":[]},\"width\":700,\"height\":432.6328800988875,\"buffer\":{\"accessors\":[{\"bufferView\":0,\"componentType\":5126,\"count\":210,\"type\":\"VEC3\"},{\"bufferView\":1,\"componentType\":5126,\"count\":210,\"type\":\"VEC3\"},{\"bufferView\":2,\"componentType\":5121,\"count\":210,\"type\":\"VEC4\",\"normalized\":true},{\"bufferView\":3,\"componentType\":5126,\"count\":180,\"type\":\"VEC3\"},{\"bufferView\":4,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":5,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":6,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":7,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":8,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":9,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":10,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":11,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":12,\"componentType\":5126,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":13,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"},{\"bufferView\":14,\"componentType\":5121,\"count\":1,\"type\":\"VEC3\"},{\"bufferView\":15,\"componentType\":5126,\"count\":15,\"type\":\"VEC3\"},{\"bufferView\":16,\"componentType\":5121,\"count\":1,\"type\":\"VEC4\"}],\"bufferViews\":[{\"buffer\":0,\"byteLength\":2520,\"byteOffset\":0},{\"buffer\":0,\"byteLength\":2520,\"byteOffset\":2520},{\"buffer\":0,\"byteLength\":840,\"byteOffset\":5040},{\"buffer\":0,\"byteLength\":2160,\"byteOffset\":5880},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":8040},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":8052},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":8056},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":8068},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":8080},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":8084},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":8096},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":8108},{\"buffer\":0,\"byteLength\":12,\"byteOffset\":8112},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":8124},{\"buffer\":0,\"byteLength\":3,\"byteOffset\":8128},{\"buffer\":0,\"byteLength\":180,\"byteOffset\":8132},{\"buffer\":0,\"byteLength\":4,\"byteOffset\":8312}],\"buffers\":[{\"byteLength\":8316,\"bytes\":\"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\\nZr8zhco+o3OwPToQWr+RRwQ/uN8JPvqYJr8eSz8/ULkNPuxmPL+RqSk/JODDPW7AXb9oGfs+\\nhJ5RPRq6Zr9zRNw+HPQBPUZuaL/H+NU+6LUzPaeiYr+jCO0+u7INPTDeU7+/aw8/AnOtPR9C\\nN7++bjE/Na04PmzqxL5UwWc/H1CMPpQewT1PA3U/bjCGPi/dXj7Gr3A/nAE8PqdF9z67Lls/\\nG0gAPsqKKz9yTDs/TX5KPo4J8z5Oj1s/VPKTPsYNmD4v/Wg/5xsOPpGTMj/R9DM/UE3TPoS5\\nCj+gbTs/l+/nPrGLDz4/Y2E/aT87PlBvOb8ULCo/NMs4PhJ+Zb8NOM8+jn9NPsVtLb8UKTU/\\nzPvwPYcXPjxJNH4/suwzPnR4h750vnI/tLMLPtZPNb/MUTE/lVOBPfw8U783tg8/8RAlPb83\\nWr/NdAU/MsKCPUHtWr9frgM/wRBZPee9Pr9PNCo/j1G0PSHjE79Rvk8/tpRRPg+i577ANV4/\\nsWaKPgRMhb6MSW0/B+uGPgxLOr1mrXY/pKsrPtzWLT999TY/aqeVPWaqYz9pH+c+fjc0PvNq\\nLD/eyTc/neKTPqyBrj4ICGU//6EA///JAP//yQD//8kA///JAP//8QD///EA///xAP//8QD/\\n//EA///xAP//8QD///EA///xAP//8QD/5P8A/7v/AP9r/wD/a/8A/wDxDf8AKNb//6EA//+h\\nAP//oQD//8kA///JAP//yQD//8kA///JAP//yQD///EA///xAP//8QD///EA///xAP/k/wD/\\n5P8A/7v/AP+T/wD/Q/8A/wDxDf8AKNb//6EA//+hAP//oQD//8kA///JAP//8QD//8kA///J\\nAP//yQD///EA///xAP//8QD///EA///xAP//8QD/5P8A/7v/AP+T/wD/Q/8A/wDxDf8AAP//\\n/6EA//94AP//oQD//6EA//+hAP//yQD//8kA///JAP//yQD//8kA///JAP//yQD///EA///x\\nAP//8QD/5P8A/7v/AP+T/wD/Q/8A/wDxDf8AKNb//6EA//94AP//oQD//6EA//+hAP//yQD/\\n/6EA//+hAP//yQD//8kA//+hAP//yQD//8kA///xAP//8QD/5P8A/7v/AP+T/wD/Q/8A/wDx\\nDf8AKNb//1AA//9QAP//eAD//6EA//+hAP//oQD//6EA//+hAP//oQD//8kA///JAP//yQD/\\n/8kA///xAP//8QD///EA/7v/AP+T/wD/Q/8A/wDxDf8AKNb//ygA//9QAP//UAD//3gA//94\\nAP//eAD//6EA//+hAP//yQD//8kA///JAP//yQD//8kA///JAP//8QD///EA/7v/AP+T/wD/\\nQ/8A/wDxDf8AKNb//wAA//8oAP//UAD//1AA//94AP//eAD//3gA//+hAP//oQD//6EA///J\\nAP//yQD//8kA///JAP//yQD///EA/+T/AP+T/wD/Q/8A/wDxDf8AAP///wAA//8AAP//KAD/\\n/1AA//9QAP//eAD//3gA//94AP//eAD//6EA//+hAP//oQD//6EA//+hAP//yQD///EA/7v/\\nAP+T/wD/Q/8A/wDxDf8AAP///wAA//8AAP//KAD//ygA//9QAP//UAD//3gA//94AP//eAD/\\n/6EA//+hAP//oQD//6EA//+hAP//yQD///EA/+T/AP9r/wD/Gv8A/wDxDf8AAP//AADAPpqZ\\nGT4k2C5AAACQP5qZGT5ITidAAADgP5qZGT4XoxhAAAAQQJqZGT6kfAlAAAAwQJqZGT6JQgZA\\nAABQQJqZGT5VQgJAAABwQJqZGT7Ok/0/AACQQJqZGT5y0Pg/AACwQJqZGT4aTPI/AADQQJqZ\\nGT7AN+k/AADwQJqZGT5pMOk/AAAIQZqZGT4N1Oc/AAAYQZqZGT7Q4OI/AAAwQZqZGT5iINQ/\\nAABQQZqZGT79qq0/AABwQZqZGT43ZHY/AACQQZqZGT43NL4+AAC0QZqZGT5PIYC+AADcQZqZ\\nGT4SWYS/AAAMQpqZGT59eTvAAADAPgAAgD5v5TJAAACQPwAAgD5x2DFAAADgPwAAgD5M0R9A\\nAAAQQAAAgD7TowtAAAAwQAAAgD4Y2QZAAABQQAAAgD6TGQdAAABwQAAAgD4AaAhAAACQQAAA\\ngD4GWgVAAACwQAAAgD4OxQBAAADQQAAAgD5CqvU/AADwQAAAgD7YQPY/AAAIQQAAgD4syPY/\\nAAAYQQAAgD4iq+k/AAAwQQAAgD7cYNI/AABQQQAAgD5spLQ/AABwQQAAgD6TsoU/AACQQQAA\\ngD73aeo+AAC0QQAAgD5Lh2i+AADcQQAAgD6sSYy/AAAMQgAAgD4UFT7AAADAPjMzsz5puDNA\\nAACQPzMzsz6m4DBAAADgPzMzsz7L6yJAAAAQQDMzsz72PyFAAAAwQDMzsz68KRlAAABQQDMz\\n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\\n\"}]},\"context\":{\"shiny\":false,\"rmarkdown\":null},\"vertexShader\":\"#line 2 1\\n// File 1 is the vertex shader\\n#ifdef GL_ES\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nprecision highp float;\\n#else\\nprecision mediump float;\\n#endif\\n#endif\\n\\nattribute vec3 aPos;\\nattribute vec4 aCol;\\nuniform mat4 mvMatrix;\\nuniform mat4 prMatrix;\\nvarying vec4 vCol;\\nvarying vec4 vPosition;\\n\\n#ifdef NEEDS_VNORMAL\\nattribute vec3 aNorm;\\nuniform mat4 normMatrix;\\nvarying vec4 vNormal;\\n#endif\\n\\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\\nattribute vec2 aTexcoord;\\nvarying vec2 vTexcoord;\\n#endif\\n\\n#ifdef FIXED_SIZE\\nuniform vec3 textScale;\\n#endif\\n\\n#ifdef FIXED_QUADS\\nattribute vec3 aOfs;\\n#endif\\n\\n#ifdef IS_TWOSIDED\\n#ifdef HAS_NORMALS\\nvarying float normz;\\nuniform mat4 invPrMatrix;\\n#else\\nattribute vec3 aPos1;\\nattribute vec3 aPos2;\\nvarying float normz;\\n#endif\\n#endif // IS_TWOSIDED\\n\\n#ifdef FAT_LINES\\nattribute vec3 aNext;\\nattribute vec2 aPoint;\\nvarying vec2 vPoint;\\nvarying float vLength;\\nuniform float uAspect;\\nuniform float uLwd;\\n#endif\\n\\n#ifdef USE_ENVMAP\\nvarying vec3 vReflection;\\n#endif\\n\\nvoid main(void) {\\n  \\n#ifndef IS_BRUSH\\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\\n  vPosition = mvMatrix * vec4(aPos, 1.);\\n#endif\\n  \\n#ifndef FIXED_QUADS\\n  gl_Position = prMatrix * vPosition;\\n#endif\\n#endif // !IS_BRUSH\\n  \\n#ifdef IS_POINTS\\n  gl_PointSize = POINTSIZE;\\n#endif\\n  \\n  vCol = aCol;\\n  \\n// USE_ENVMAP implies NEEDS_VNORMAL\\n\\n#ifdef NEEDS_VNORMAL\\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\\n#endif\\n\\n#ifdef USE_ENVMAP\\n  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \\n                        normalize(vNormal.xyz/vNormal.w)));\\n#endif\\n  \\n#ifdef IS_TWOSIDED\\n#ifdef HAS_NORMALS\\n  /* normz should be calculated *after* projection */\\n  normz = (invPrMatrix*vNormal).z;\\n#else\\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\\n#endif\\n#endif // IS_TWOSIDED\\n  \\n#ifdef NEEDS_VNORMAL\\n  vNormal = vec4(normalize(vNormal.xyz), 1);\\n#endif\\n  \\n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\\n  vTexcoord = aTexcoord;\\n#endif\\n  \\n#if defined(FIXED_SIZE) && !defined(ROTATING)\\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\\n  pos = pos/pos.w;\\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\\n#endif\\n  \\n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\\n  pos = pos/pos.w + vec4(aOfs,  0.);\\n  gl_Position = prMatrix*pos;\\n#endif\\n  \\n#ifdef FAT_LINES\\n  /* This code was inspired by Matt Deslauriers' code in \\n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\\n  vec2 aspectVec = vec2(uAspect, 1.0);\\n  mat4 projViewModel = prMatrix * mvMatrix;\\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\\n  currentProjected = currentProjected/currentProjected.w;\\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\\n  vec2 currentScreen = currentProjected.xy * aspectVec;\\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\\n  float len = uLwd;\\n  vec2 dir = vec2(1.0, 0.0);\\n  vPoint = aPoint;\\n  vLength = length(nextScreen - currentScreen)/2.0;\\n  vLength = vLength/(vLength + len);\\n  if (vLength > 0.0) {\\n    dir = normalize(nextScreen - currentScreen);\\n  }\\n  vec2 normal = vec2(-dir.y, dir.x);\\n  dir.x /= uAspect;\\n  normal.x /= uAspect;\\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\\n  gl_Position = currentProjected + offset;\\n#endif\\n  \\n#ifdef IS_BRUSH\\n  gl_Position = vec4(aPos, 1.);\\n#endif\\n}\",\"fragmentShader\":\"#line 2 2\\n// File 2 is the fragment shader\\n#ifdef GL_ES\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nprecision highp float;\\n#else\\nprecision mediump float;\\n#endif\\n#endif\\nvarying vec4 vCol; // carries alpha\\nvarying vec4 vPosition;\\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\\nvarying vec2 vTexcoord;\\nuniform sampler2D uSampler;\\n#endif\\n\\n#ifdef HAS_FOG\\nuniform int uFogMode;\\nuniform vec3 uFogColor;\\nuniform vec4 uFogParms;\\n#endif\\n\\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\\nvarying vec4 vNormal;\\n#endif\\n\\n#if NCLIPPLANES > 0\\nuniform vec4 vClipplane[NCLIPPLANES];\\n#endif\\n\\n#if NLIGHTS > 0\\nuniform mat4 mvMatrix;\\n#endif\\n\\n#ifdef IS_LIT\\nuniform vec3 emission;\\nuniform float shininess;\\n#if NLIGHTS > 0\\nuniform vec3 ambient[NLIGHTS];\\nuniform vec3 specular[NLIGHTS]; // light*material\\nuniform vec3 diffuse[NLIGHTS];\\nuniform vec3 lightDir[NLIGHTS];\\nuniform bool viewpoint[NLIGHTS];\\nuniform bool finite[NLIGHTS];\\n#endif\\n#endif // IS_LIT\\n\\n#ifdef IS_TWOSIDED\\nuniform bool front;\\nvarying float normz;\\n#endif\\n\\n#ifdef FAT_LINES\\nvarying vec2 vPoint;\\nvarying float vLength;\\n#endif\\n\\n#ifdef USE_ENVMAP\\nvarying vec3 vReflection;\\n#endif\\n\\nvoid main(void) {\\n  vec4 fragColor;\\n#ifdef FAT_LINES\\n  vec2 point = vPoint;\\n  bool neg = point.y < 0.0;\\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\\n                 -(point.y - vLength)/(1.0 - vLength);\\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\\n  if (neg && length(point) <= 1.0) discard;\\n#endif\\n  point.y = min(point.y, 0.0);\\n  if (length(point) > 1.0) discard;\\n#endif // FAT_LINES\\n  \\n#ifdef ROUND_POINTS\\n  vec2 coord = gl_PointCoord - vec2(0.5);\\n  if (length(coord) > 0.5) discard;\\n#endif\\n  \\n#if NCLIPPLANES > 0\\n  for (int i = 0; i < NCLIPPLANES; i++)\\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\\n#endif\\n    \\n#ifdef FIXED_QUADS\\n    vec3 n = vec3(0., 0., 1.);\\n#elif defined(IS_LIT)\\n    vec3 n = normalize(vNormal.xyz);\\n#endif\\n    \\n#ifdef IS_TWOSIDED\\n    if ((normz <= 0.) != front) discard;\\n#endif\\n\\n#ifdef IS_LIT\\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\\n    vec3 lightdir;\\n    vec4 colDiff;\\n    vec3 halfVec;\\n    vec4 lighteffect = vec4(emission, 0.);\\n    vec3 col;\\n    float nDotL;\\n#ifdef FIXED_QUADS\\n    n = -faceforward(n, n, eye);\\n#endif\\n    \\n#if NLIGHTS > 0\\n    // Simulate two-sided lighting\\n    if (n.z < 0.0)\\n      n = -n;\\n    for (int i=0;i<NLIGHTS;i++) {\\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\\n      lightdir = lightDir[i];\\n      if (!viewpoint[i]) {\\n        if (finite[i]) {\\n          lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\\n        } else {\\n          lightdir = (mvMatrix * vec4(lightdir, 0.)).xyz;\\n        }\\n      }\\n      if (!finite[i]) {\\n        halfVec = normalize(lightdir + eye);\\n      } else {\\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\\n        halfVec = normalize(lightdir + eye);\\n      }\\n      col = ambient[i];\\n      nDotL = dot(n, lightdir);\\n      col = col + max(nDotL, 0.) * colDiff.rgb;\\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\\n      lighteffect = lighteffect + vec4(col, colDiff.a);\\n    }\\n#endif\\n    \\n#else // not IS_LIT\\n    vec4 colDiff = vCol;\\n    vec4 lighteffect = colDiff;\\n#endif\\n    \\n#ifdef IS_TEXT\\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\\n#endif\\n    \\n#ifdef HAS_TEXTURE\\n\\n// These calculations use the definitions from \\n// https://docs.gl/gl3/glTexEnv\\n\\n#ifdef USE_ENVMAP\\n    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\\n    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\\n#else\\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\\n#endif\\n\\n#ifdef TEXTURE_rgb\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(textureColor.rgb, lighteffect.a);\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\\n#endif\\n\\n#endif //TEXTURE_rgb\\n        \\n#ifdef TEXTURE_rgba\\n\\n#ifdef TEXMODE_replace\\n// already done\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = lighteffect*textureColor;\\n#endif\\n\\n#ifdef TEXMODE_decal\\n    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\\n                     textureColor.a*textureColor.rgb, \\n                     lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\\n                    lighteffect.a*textureColor.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\\n                    lighteffect.a*textureColor.a);\\n#endif\\n    \\n#endif //TEXTURE_rgba\\n    \\n#ifdef TEXTURE_alpha\\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(lighteffect.rgb, luminance);\\n#endif \\n\\n#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\\n    textureColor = vec4(lighteffect.rgb, lighteffect.a*luminance);\\n#endif\\n \\n#endif // TEXTURE_alpha\\n    \\n// The TEXTURE_luminance values are not from that reference    \\n#ifdef TEXTURE_luminance\\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\\n                        lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\\n#endif\\n\\n#endif // TEXTURE_luminance\\n \\n    \\n#ifdef TEXTURE_luminance_alpha\\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\\n\\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\\n    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\\n#endif \\n\\n#ifdef TEXMODE_modulate\\n    textureColor = vec4(luminance*lighteffect.rgb, \\n                        textureColor.a*lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_blend\\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\\n                        textureColor.a*lighteffect.a);\\n#endif\\n\\n#ifdef TEXMODE_add\\n    textureColor = vec4(luminance + lighteffect.rgb, \\n                        textureColor.a*lighteffect.a);\\n\\n#endif\\n\\n#endif // TEXTURE_luminance_alpha\\n    \\n    fragColor = textureColor;\\n\\n#elif defined(IS_TEXT)\\n    if (textureColor.a < 0.1)\\n      discard;\\n    else\\n      fragColor = textureColor;\\n#else\\n    fragColor = lighteffect;\\n#endif // HAS_TEXTURE\\n    \\n#ifdef HAS_FOG\\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\\n    // In Exp and Exp2: use density = density/far\\n    // fogF will be the proportion of fog\\n    // Initialize it to the linear value\\n    float fogF;\\n    if (uFogMode > 0) {\\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\\n      if (uFogMode > 1)\\n        fogF = mix(uFogParms.w, 1.0, fogF);\\n      fogF = fogF*uFogParms.z;\\n      if (uFogMode == 2)\\n        fogF = 1.0 - exp(-fogF);\\n      // Docs are wrong: use (density*c)^2, not density*c^2\\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\\n      else if (uFogMode == 3)\\n        fogF = 1.0 - exp(-fogF*fogF);\\n      fogF = clamp(fogF, 0.0, 1.0);\\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\\n    } else gl_FragColor = fragColor;\\n#else\\n    gl_FragColor = fragColor;\\n#endif // HAS_FOG\\n    \\n}\",\"players\":[],\"webGLoptions\":{\"preserveDrawingBuffer\":true},\"fastTransparency\":true},\"evals\":[],\"jsHooks\":[]}# }"},{"path":"https://natverse.org/nat.nblast/reference/diagonal.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract diagonal terms from a variety of matrix types — diagonal","title":"Extract diagonal terms from a variety of matrix types — diagonal","text":"Extract diagonal terms variety matrix types","code":""},{"path":"https://natverse.org/nat.nblast/reference/diagonal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract diagonal terms from a variety of matrix types — diagonal","text":"","code":"diagonal(x, indices = NULL)  # Default S3 method diagonal(x, indices = NULL)"},{"path":"https://natverse.org/nat.nblast/reference/diagonal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract diagonal terms from a variety of matrix types — diagonal","text":"x square matrix indices specifies subset diagonal using character vector names, logical vector integer indices. default (NULL) implies elements.","code":""},{"path":"https://natverse.org/nat.nblast/reference/diagonal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract diagonal terms from a variety of matrix types — diagonal","text":"named vector containing diagonal elements.","code":""},{"path":"https://natverse.org/nat.nblast/reference/diagonal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract diagonal terms from a variety of matrix types — diagonal","text":"Insists input matrix square. Uses 'diagonal'   attribute available specialised handling ff,   big.matrix, dgCMatrix matrices. check row   column names identical matrix classes (unlike base   diag function, always uses rownames.","code":""},{"path":"https://natverse.org/nat.nblast/reference/diagonal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract diagonal terms from a variety of matrix types — diagonal","text":"","code":"m=fill_in_sparse_score_mat(letters[1:5]) diagonal(m) #> a b c d e  #> 0 0 0 0 0"},{"path":"https://natverse.org/nat.nblast/reference/extract-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract parts of a sparse spam matrix — [","title":"Extract parts of a sparse spam matrix — [","text":"Extract parts sparse spam matrix","code":""},{"path":"https://natverse.org/nat.nblast/reference/extract-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract parts of a sparse spam matrix — [","text":"","code":"# S4 method for class 'spam,character,character,logical' x[i, j, ..., drop = TRUE]  # S4 method for class 'spam,character,character,missing' x[i, j, ..., drop = TRUE]  # S4 method for class 'spam,character,missing,logical' x[i, j, ..., drop = TRUE]  # S4 method for class 'spam,character,missing,missing' x[i, j, ..., drop = TRUE]  # S4 method for class 'spam,missing,character,logical' x[i, j, ..., drop = TRUE]  # S4 method for class 'spam,missing,character,missing' x[i, j, ..., drop = TRUE]"},{"path":"https://natverse.org/nat.nblast/reference/extract-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract parts of a sparse spam matrix — [","text":"x object extract . row identifiers. j column identifiers. ... additional arguments. drop logical indicating dimensions dropped.","code":""},{"path":"https://natverse.org/nat.nblast/reference/fctraces20.html","id":null,"dir":"Reference","previous_headings":"","what":"20 traced Drosophila neurons from Chiang et al 2011 — fctraces20","title":"20 traced Drosophila neurons from Chiang et al 2011 — fctraces20","text":"R list (additional class neuronlist) contains 15 skeletonized Drosophila neurons dotprops objects. Original data due Chiang et al. [1], generously shared raw data. Automated tracing neuron skeletons carried Lee et al [2]. Image registration processing carried Greg Jefferis, Marta Costa James Manton[3].","code":""},{"path":"https://natverse.org/nat.nblast/reference/fctraces20.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"20 traced Drosophila neurons from Chiang et al 2011 — fctraces20","text":"[1] Chiang .S., Lin C.Y., Chuang C.C., Chang H.M., Hsieh C.H.,   Yeh C.W., Shih C.T., Wu J.J., Wang G.T., Chen Y.C., Wu C.C., Chen G.Y.,   Ching Y.T., Lee P.C., Lin C.Y., Lin H.H., Wu C.C., Hsu H.W., Huang Y..,   Chen J.Y., et al. (2011). Three-dimensional reconstruction brain-wide   wiring networks Drosophila single-cell resolution. Curr Biol 21 (1),   1–11. doi: doi:10.1016/j.cub.2010.11.056 [2] P.-C. Lee, C.-C. Chuang, .-S. Chiang, Y.-T. Ching. (2012).   High-throughput computer method 3d neuronal structure reconstruction   image stack Drosophila brain applications. PLoS   Comput Biol, 8(9):e1002658, Sep 2012. doi:   doi:10.1371/journal.pcbi.1002658 . [3] NBLAST: Rapid, sensitive comparison neuronal structure   construction neuron family databases. Marta Costa, Aaron D. Ostrovsky,   James D. Manton, Steffen Prohaska, Gregory S.X.E. Jefferis. bioRxiv doi:   doi:10.1101/006346 .","code":""},{"path":"https://natverse.org/nat.nblast/reference/fill_in_sparse_score_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Add one or more submatrices to a sparse score matrix — fill_in_sparse_score_mat","title":"Add one or more submatrices to a sparse score matrix — fill_in_sparse_score_mat","text":"Add one submatrices sparse score matrix","code":""},{"path":"https://natverse.org/nat.nblast/reference/fill_in_sparse_score_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add one or more submatrices to a sparse score matrix — fill_in_sparse_score_mat","text":"","code":"fill_in_sparse_score_mat(sparse_matrix, ..., diag = NULL)"},{"path":"https://natverse.org/nat.nblast/reference/fill_in_sparse_score_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add one or more submatrices to a sparse score matrix — fill_in_sparse_score_mat","text":"sparse_matrix either existing (square) sparse matrix character vector names used define empty sparse matrix. ... Additional matrices insert sparse_matrix. Row column names must matches sparse_matrix. diag optional full diagonal sparse matrix .e. self-match scores.","code":""},{"path":[]},{"path":"https://natverse.org/nat.nblast/reference/fill_pairs_sparse_score_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Add forwards, reverse and self scores for a pair of neurons to a sparse score matrix — fill_pairs_sparse_score_mat","title":"Add forwards, reverse and self scores for a pair of neurons to a sparse score matrix — fill_pairs_sparse_score_mat","text":"Add forwards, reverse self scores pair neurons sparse score matrix","code":""},{"path":"https://natverse.org/nat.nblast/reference/fill_pairs_sparse_score_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add forwards, reverse and self scores for a pair of neurons to a sparse score matrix — fill_pairs_sparse_score_mat","text":"","code":"fill_pairs_sparse_score_mat(   sparse_matrix,   n1,   n2,   dense_matrix,   reverse = TRUE,   self = TRUE,   reverse_self = (reverse && self) )"},{"path":"https://natverse.org/nat.nblast/reference/fill_pairs_sparse_score_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add forwards, reverse and self scores for a pair of neurons to a sparse score matrix — fill_pairs_sparse_score_mat","text":"sparse_matrix sparse matrix fill . n1 name query neuron. n2 name target neuron. dense_matrix score matrix extract scores. reverse logical indicating reverse score also filled (default TRUE). self logical indicating self-score query also filled (used normalised scores; default TRUE). reverse_self logical indicating self-score target also filled (used mean scores; default TRUE).","code":""},{"path":"https://natverse.org/nat.nblast/reference/fill_pairs_sparse_score_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add forwards, reverse and self scores for a pair of neurons to a sparse score matrix — fill_pairs_sparse_score_mat","text":"sparse matrix (class spam) specified score entries filled.","code":""},{"path":"https://natverse.org/nat.nblast/reference/nat.nblast-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Neuron similarity, search and clustering tools — nat.nblast-package","title":"Neuron similarity, search and clustering tools — nat.nblast-package","text":"nat.nblast provides tools compare neuronal morphology using NBLAST algorithm (Costa et al. 2016).","code":""},{"path":"https://natverse.org/nat.nblast/reference/nat.nblast-package.html","id":"similarity-and-search","dir":"Reference","previous_headings":"","what":"Similarity and search","title":"Neuron similarity, search and clustering tools — nat.nblast-package","text":"main entry point similarity search functions   nblast. Traced neurons normally converted   dotprops format search. multiple neurons   compared neuronlist object. current NBLAST version (2) depends scoring matrix. Default   matrices trained using Drosophila neurons FCWB template brain   space distributed package (see smat.fcwb); see   Scoring Matrices section creating new scoring matrices. nblast makes use flexible complicated function   NeuriteBlast includes several additional options. function   WeightedNNBasedLinesetMatching provides primitive functionality   finding nearest neighbour distances absolute dot products   two sets segments. Neither functions intended end use. Calculating similarity scores facilitated   nblast_allbyall function can take either   neuronlist input character vector naming (  subset) neurons (large) neuronlist.   neuronlist containing input neurons   resident memory .e. neuronlistfh.","code":""},{"path":"https://natverse.org/nat.nblast/reference/nat.nblast-package.html","id":"clustering","dir":"Reference","previous_headings":"","what":"Clustering","title":"Neuron similarity, search and clustering tools — nat.nblast-package","text":"similarity score matrix available can used   input variety clustering algorithms. nhclust   provides convenient wrapper R's hierarchical clustering function   hclust. wish use another clustering function,   can use sub_dist_mat convert raw similarity   score matrix normalised distance matrix (R dist   object) suitable clustering. need similarity matrix want   modify normalisation can use sub_score_mat. Note raw NBLAST scores symmetric (.e. S(,B) equal   S(B,)) clustering construct symmetric similarity/distance   matrix 1/2 * ( S(,B)/S(,) + S(B,)/S(B,B) ). See   sub_score_mat's documentation details.","code":""},{"path":"https://natverse.org/nat.nblast/reference/nat.nblast-package.html","id":"cached-scores","dir":"Reference","previous_headings":"","what":"Cached scores","title":"Neuron similarity, search and clustering tools — nat.nblast-package","text":"Although NBLAST fast can parallelised, makes sense cache   disk similarity scores group neurons   subject repeated clustering analysis. matrix can simply   saved disk reloaded using base R functions like   save load. sub_score_mat   sub_dist_mat can used extract subset scores   raw score matrix. large matrices, bigmemory   ff packages allow matrices stored disk portions loaded   memory demand. sub_score_mat   sub_dist_mat work equally well regular -memory matrices   disk-backed matrices. give example, 16,129 neurons flycircuit.tw dataset,   260,144,641 comparisons took 250 hours compute time (half day   ~20 cores). saved disk single precision (.e. 4 bytes per score)   ff matrix occupy just 1Gb.","code":""},{"path":"https://natverse.org/nat.nblast/reference/nat.nblast-package.html","id":"calculating-scoring-matrices","dir":"Reference","previous_headings":"","what":"Calculating scoring matrices","title":"Neuron similarity, search and clustering tools — nat.nblast-package","text":"NBLAST algorithm depends appropriately calibrated scoring matrices.   encapsulate log odds ratio pair segments come two   structurally related neurons rather two unrelated neurons, given   observed distance absolute dot product two segments. Scoring   matrices can constructed using create_scoringmatrix   function, supplying set matching neurons set non-matching   neurons. See create_scoringmatrix documentation links   lower-level functions provide finer control construction   scoring matrix.","code":""},{"path":"https://natverse.org/nat.nblast/reference/nat.nblast-package.html","id":"package-options","dir":"Reference","previous_headings":"","what":"Package Options","title":"Neuron similarity, search and clustering tools — nat.nblast-package","text":"one package option nat.nblast.defaultsmat   NULL default, example set one scoring   matrices included package \"smat.fcwb\" new   user-constructed matrix.","code":""},{"path":"https://natverse.org/nat.nblast/reference/nat.nblast-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Neuron similarity, search and clustering tools — nat.nblast-package","text":"Costa, M., Ostrovsky, .D., Manton, J.D., Prohaska, S.,   Jefferis, G.S.X.E. (2014). NBLAST: Rapid, sensitive comparison neuronal   structure construction neuron family databases. bioRxiv preprint.   doi:10.1101/006346 .","code":""},{"path":[]},{"path":"https://natverse.org/nat.nblast/reference/nat.nblast-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Neuron similarity, search and clustering tools — nat.nblast-package","text":"Maintainer: Gregory Jefferis jefferis@gmail.com (ORCID) Authors: James Manton ajd.manton@googlemail.com (ORCID)","code":""},{"path":"https://natverse.org/nat.nblast/reference/nblast.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate similarity score for neuron morphologies — nblast","title":"Calculate similarity score for neuron morphologies — nblast","text":"Uses NBLAST algorithm compares morphology two neurons. control parameters algorithm, see arguments NeuriteBlast.","code":""},{"path":"https://natverse.org/nat.nblast/reference/nblast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate similarity score for neuron morphologies — nblast","text":"","code":"nblast(   query,   target = getOption(\"nat.default.neuronlist\"),   smat = NULL,   sd = 3,   version = c(2, 1),   normalised = FALSE,   UseAlpha = FALSE,   OmitFailures = NA,   ... )"},{"path":"https://natverse.org/nat.nblast/reference/nblast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate similarity score for neuron morphologies — nblast","text":"query query neuron. target neuronlist compare neuron . Defaults options(\"nat.default.neuronlist\"). See nat-package. smat scoring matrix use (see details) sd Standard deviation use distance dependence NBLAST v1 algorithm. Ignored version=2. version version algorithm use (default, 2, latest). normalised whether divide scores self-match score query UseAlpha whether weight similarity score matched segment emphasise long range neurites rather arbours (default: FALSE, see UseAlpha section details). OmitFailures Whether omit neurons FUN gives error. default value (NA) result nblast stopping error message moment error. values, see details. ... Additional arguments passed NeuriteBlast function used compute scores distances/dot products. (expert use ).","code":""},{"path":"https://natverse.org/nat.nblast/reference/nblast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate similarity score for neuron morphologies — nblast","text":"Named list similarity scores.","code":""},{"path":"https://natverse.org/nat.nblast/reference/nblast.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate similarity score for neuron morphologies — nblast","text":"smat=NULL options(\"nat.nblast.defaultsmat\")   checked NULL, smat.fcwb   smat_alpha.fcwb used depending value   UseAlpha. OmitFailures NA, individual nblast calls   wrapped try ensure failure single neuron   abort whole nblast call. OmitFailures=FALSE, missing   values left NA. OmitFailures=TRUE (yet)   implemented. want drop scores neurons failed   need set OmitFailures=FALSE use na.omit   similar post-process scores. Note OmitFailures=FALSE error messages printed   call wrapped try(expr, silent=TRUE). Internally, plyr package used provide options   parallelising NBLAST displaying progress. display progress bar   scores computed, add .progress=\"natprogress\"   arguments (non-text progress bars available – see   create_progress_bar). parallelise, add   .parallel=TRUE arguments. order make use parallel   calculation, must register parallel backend distribute   computations. several possible backends, simplest   multicore option made available doMC, spreads load   across cores machine. using , backend must   registered using registerDoMC (see example ).","code":""},{"path":"https://natverse.org/nat.nblast/reference/nblast.html","id":"nblast-versions","dir":"Reference","previous_headings":"","what":"NBLAST Versions","title":"Calculate similarity score for neuron morphologies — nblast","text":"nblast version argument presently   exposes two versions algorithm; use core procedure   aligning two vector clouds, segment segment, computing   distance absolute dot product nearest segment target   neuron every segment query neuron. However differ   significantly procedure used calculate score using set   distances absolute dot products. Version 1 algorithm uses standard deviation (argument   sd) user-supplied parameter negative exponential   weighting function determines relationship score   distance segments. corresponds parameter \\(\\sigma\\)   weighting function: \\(f=\\sqrt{|\\vec{u_{}}\\cdot\\vec{v_{}}|\\exp\\left(-d_{}^{2}/2\\sigma^{2}\\right)}\\) approach described Kohl et al 2013 similarity   scores interval (0,1) described paper can exactly   recapitulated setting version=1 normalised=TRUE. Version 2 algorithm described Costa et al 2014.   uses sophisticated principled scoring approach based   log-odds ratio defined distribution matches non-matches   sample data. information passed nblast function   form scoring matrix (can computed   create_scoringmatrix); default scoring matrix   smat.fcwb constructed Drosophila neurons. version use? use version 2   working Drosophila neurons sufficient training data   (form validated matching random neuron pairs construct   scoring matrix). case, can always fall back   version 1, setting free parameter (sd \\(\\sigma\\)) value   encapsulates understanding location precision neurons   species/brain region interest. fly brain used   \\(\\sigma=3\\) microns, since previous estimates localisation   identifiable features neurons (Jefferis, Potter et al 2007)   order.","code":""},{"path":"https://natverse.org/nat.nblast/reference/nblast.html","id":"usealpha","dir":"Reference","previous_headings":"","what":"UseAlpha","title":"Calculate similarity score for neuron morphologies — nblast","text":"NBLAST v2, alpha factor segment   indicates whether neighbouring segments aligned similar direction   (typical e.g. long range axonal projection) randomly aligned   (typical dendritic arbours). See Costa et al. details. Setting   UseAlpha=TRUE emphasise axon, primary neurite etc.   neuron. can particularly useful option e.g.   searching traced fragment know suspect follow axon   tract.","code":""},{"path":"https://natverse.org/nat.nblast/reference/nblast.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate similarity score for neuron morphologies — nblast","text":"Kohl, J. Ostrovsky, .D., Frechter, S., Jefferis, G.S.X.E   (2013). bidirectional circuit switch reroutes pheromone signals male   female brains. Cell 155 (7), 1610–23 doi:10.1016/j.cell.2013.11.025 . Costa, M., Ostrovsky, .D., Manton, J.D., Prohaska, S., Jefferis,   G.S.X.E. (2014). NBLAST: Rapid, sensitive comparison neuronal structure   construction neuron family databases. bioRxiv preprint.   doi:10.1101/006346 . Jefferis G.S.X.E., Potter C.J., Chan .M., Marin E.C., Rohlfing T., Maurer   C.R.J., Luo L. (2007). Comprehensive maps Drosophila higher   olfactory centers: spatially segregated fruit pheromone representation.   Cell 128 (6), 1187–1203. doi:10.1016/j.cell.2007.01.040","code":""},{"path":[]},{"path":"https://natverse.org/nat.nblast/reference/nblast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate similarity score for neuron morphologies — nblast","text":"","code":"# load sample Kenyon cell data from nat package data(kcs20, package='nat') # search one neuron against all neurons scores=nblast(kcs20[['GadMARCM-F000142_seg002']], kcs20) # scores from best to worst, top hit is of course same neuron sort(scores, decreasing = TRUE) #> GadMARCM-F000142_seg002 ChaMARCM-F000586_seg002 GadMARCM-F000423_seg001  #>               4043.1766               1914.8224               1772.8506  #> GadMARCM-F000442_seg002 FruMARCM-M000115_seg001 FruMARCM-F000085_seg001  #>               1007.4565                853.8108                713.2106  #> FruMARCM-F001929_seg001 FruMARCM-F001494_seg002 GadMARCM-F000050_seg001  #>                604.4071                481.4737                480.4146  #> GadMARCM-F000071_seg001 FruMARCM-M001339_seg001 FruMARCM-F000188_seg001  #>                448.1516                433.9340                404.0470  #> GadMARCM-F000476_seg001 FruMARCM-F000270_seg001 FruMARCM-F000706_seg001  #>                313.2021                254.7516                204.2116  #> FruMARCM-M000842_seg002 FruMARCM-M001051_seg002 FruMARCM-M001205_seg002  #>                196.4543                140.8164               -251.4999  #> GadMARCM-F000122_seg001 FruMARCM-F001115_seg002  #>               -262.2352               -520.2581  hist(scores, breaks=25, col='grey') abline(v=1500, col='red')   # plot query neuron open3d() # plot top 3 hits (including self match with thicker lines) plot3d(kcs20[which(sort(scores, decreasing = TRUE)>1500)], lwd=c(3,1,1)) rest=names(which(scores<1500)) plot3d(rest, db=kcs20, col='grey', lwd=0.5)  # normalised scores (i.e. self match = 1) of all neurons vs each other # note use of progress bar scores.norm=nblast(kcs20, kcs20, normalised = TRUE, .progress=\"natprogress\") #> Warning: Cannot find progress bar progress_natprogress hist(scores.norm, breaks=25, col='grey')  # produce a heatmap from normalised scores jet.colors <- colorRampPalette( c(\"blue\", \"green\", \"yellow\", \"red\") ) heatmap(scores.norm, labCol = with(kcs20,type), col=jet.colors(20), symm = TRUE)   if (FALSE) { # \\dontrun{ # Parallelise NBLASTing across 4 cores using doMC package library(doMC) registerDoMC(4) scores.norm2=nblast(kcs20, kcs20, normalised=TRUE, .parallel=TRUE) stopifnot(all.equal(scores.norm2, scores.norm)) } # }"},{"path":"https://natverse.org/nat.nblast/reference/nblast_allbyall.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrapper function to compute all by all NBLAST scores for a set of neurons — nblast_allbyall","title":"Wrapper function to compute all by all NBLAST scores for a set of neurons — nblast_allbyall","text":"Calls nblast compute actual scores. Can accept   either neuronlist neuron names character   vector. thin wrapper around nblast main advantage   option \"mean\" normalisation forward reverse scores,   sensible input give clustering algorithm well   choice returning distance matrix.","code":""},{"path":"https://natverse.org/nat.nblast/reference/nblast_allbyall.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrapper function to compute all by all NBLAST scores for a set of neurons — nblast_allbyall","text":"","code":"nblast_allbyall(x, ...)  # S3 method for class 'character' nblast_allbyall(x, smat = NULL, db = getOption(\"nat.default.neuronlist\"), ...)  # S3 method for class 'neuronlist' nblast_allbyall(   x,   smat = NULL,   distance = FALSE,   normalisation = c(\"raw\", \"normalised\", \"mean\"),   ... )"},{"path":"https://natverse.org/nat.nblast/reference/nblast_allbyall.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrapper function to compute all by all NBLAST scores for a set of neurons — nblast_allbyall","text":"x Input neurons (neuronlist character vector) ... Additional arguments methods nblast smat scoring matrix use (see details nblast meaning default NULL value) db neuronlist character vector naming one. Defaults value options(\"nat.default.neuronlist\") distance logical indicating whether return distances scores. normalisation type normalisation procedure carried , selected  'raw', 'normalised' 'mean' (.e. average normalised scores directions). distance=TRUE raw.","code":""},{"path":"https://natverse.org/nat.nblast/reference/nblast_allbyall.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Wrapper function to compute all by all NBLAST scores for a set of neurons — nblast_allbyall","text":"Note nat already provides function   nhclust clustering, wrapper R's   hclust function. nhclust actually expects raw scores   input.","code":""},{"path":"https://natverse.org/nat.nblast/reference/nblast_allbyall.html","id":"todo","dir":"Reference","previous_headings":"","what":"TODO","title":"Wrapper function to compute all by all NBLAST scores for a set of neurons — nblast_allbyall","text":"good idea future implement parallel   version function.","code":""},{"path":[]},{"path":"https://natverse.org/nat.nblast/reference/nblast_allbyall.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrapper function to compute all by all NBLAST scores for a set of neurons — nblast_allbyall","text":"","code":"library(nat) kcs20.scoremat=nblast_allbyall(kcs20) kcs20.hclust=nhclust(scoremat=kcs20.scoremat) #> The \"ward\" method has been renamed to \"ward.D\"; note new \"ward.D2\" plot(kcs20.hclust)"},{"path":"https://natverse.org/nat.nblast/reference/neuron_pairs.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility function to generate all or random pairs of neurons — neuron_pairs","title":"Utility function to generate all or random pairs of neurons — neuron_pairs","text":"Utility function generate random pairs neurons","code":""},{"path":"https://natverse.org/nat.nblast/reference/neuron_pairs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility function to generate all or random pairs of neurons — neuron_pairs","text":"","code":"neuron_pairs(query, target, n = NA, ignoreSelf = TRUE)"},{"path":"https://natverse.org/nat.nblast/reference/neuron_pairs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility function to generate all or random pairs of neurons — neuron_pairs","text":"query, target either neuronlists character vectors names. target missing, query used query target. n number random pairs draw. NA, default, uses expand.grid draw pairs. ignoreSelf Logical indicating whether omit pairs consisting neuron (default TRUE).","code":""},{"path":"https://natverse.org/nat.nblast/reference/neuron_pairs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility function to generate all or random pairs of neurons — neuron_pairs","text":"data.frame two character vector columns, query target.","code":""},{"path":[]},{"path":"https://natverse.org/nat.nblast/reference/neuron_pairs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Utility function to generate all or random pairs of neurons — neuron_pairs","text":"","code":"neuron_pairs(nat::kcs20, n=20) #>                      query                  target #> 1  FruMARCM-F000270_seg001 GadMARCM-F000122_seg001 #> 2  FruMARCM-F000270_seg001 FruMARCM-M000115_seg001 #> 3  FruMARCM-F001494_seg002 FruMARCM-M001205_seg002 #> 4  FruMARCM-F000706_seg001 FruMARCM-F001115_seg002 #> 5  GadMARCM-F000122_seg001 GadMARCM-F000050_seg001 #> 6  GadMARCM-F000476_seg001 FruMARCM-F001929_seg001 #> 7  GadMARCM-F000476_seg001 FruMARCM-F001494_seg002 #> 8  FruMARCM-F000270_seg001 FruMARCM-M001205_seg002 #> 9  FruMARCM-F000085_seg001 FruMARCM-F000188_seg001 #> 10 GadMARCM-F000122_seg001 GadMARCM-F000442_seg002 #> 11 FruMARCM-F001115_seg002 FruMARCM-F000270_seg001 #> 12 GadMARCM-F000142_seg002 ChaMARCM-F000586_seg002 #> 13 FruMARCM-F000188_seg001 FruMARCM-M001205_seg002 #> 14 GadMARCM-F000122_seg001 FruMARCM-F000706_seg001 #> 15 GadMARCM-F000050_seg001 FruMARCM-F001929_seg001 #> 16 GadMARCM-F000476_seg001 GadMARCM-F000071_seg001 #> 17 FruMARCM-M001051_seg002 FruMARCM-F000085_seg001 #> 18 FruMARCM-F001115_seg002 GadMARCM-F000050_seg001 #> 19 ChaMARCM-F000586_seg002 GadMARCM-F000122_seg001 #> 20 FruMARCM-M001339_seg001 GadMARCM-F000476_seg001"},{"path":"https://natverse.org/nat.nblast/reference/nhclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Cluster a set of neurons — nhclust","title":"Cluster a set of neurons — nhclust","text":"Given NBLAST score matrix (may specified package default) /vector neuron identifiers use hclust carry hierarchical clustering. default value distfun argument handle square distance matrices R dist objects.","code":""},{"path":"https://natverse.org/nat.nblast/reference/nhclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cluster a set of neurons — nhclust","text":"","code":"nhclust(   neuron_names,   method = \"ward\",   scoremat = NULL,   distfun = as.dist,   ...,   maxneurons = 4000 )"},{"path":"https://natverse.org/nat.nblast/reference/nhclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cluster a set of neurons — nhclust","text":"neuron_names character vector neuron identifiers. method clustering method (default Ward's). scoremat score matrix use (see sub_score_mat details default). distfun function convert distance matrix returned sub_dist_mat R dist object (default= .dist). ... additional parameters passed hclust. maxneurons set sensible value avoid loading huge (order N^2) distances directly memory.","code":""},{"path":"https://natverse.org/nat.nblast/reference/nhclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cluster a set of neurons — nhclust","text":"object class hclust describes tree   produced clustering process.","code":""},{"path":[]},{"path":"https://natverse.org/nat.nblast/reference/nhclust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cluster a set of neurons — nhclust","text":"","code":"library(nat) kcscores=nblast_allbyall(kcs20) hckcs=nhclust(scoremat=kcscores) #> The \"ward\" method has been renamed to \"ward.D\"; note new \"ward.D2\" # divide hclust object into 3 groups library(dendroextras) dkcs=colour_clusters(hckcs, k=3) # change dendrogram labels to neuron type, extracting this information # from type column in the metadata data.frame attached to kcs20 neuronlist labels(dkcs)=with(kcs20[labels(dkcs)], type) plot(dkcs)  # 3d plot of neurons in those clusters (with matching colours) open3d() plot3d(hckcs, k=3, db=kcs20) # names of neurons in 3 groups subset(hckcs, k=3) #>  [1] \"FruMARCM-F000706_seg001\" \"FruMARCM-M000842_seg002\" #>  [3] \"GadMARCM-F000050_seg001\" \"FruMARCM-M001339_seg001\" #>  [5] \"FruMARCM-F001115_seg002\" \"FruMARCM-M001051_seg002\" #>  [7] \"FruMARCM-F001494_seg002\" \"FruMARCM-F000188_seg001\" #>  [9] \"FruMARCM-F000270_seg001\" \"FruMARCM-F001929_seg001\" #> [11] \"GadMARCM-F000423_seg001\" \"GadMARCM-F000142_seg002\" #> [13] \"ChaMARCM-F000586_seg002\" \"FruMARCM-M001205_seg002\" #> [15] \"GadMARCM-F000122_seg001\" \"GadMARCM-F000476_seg001\" #> [17] \"FruMARCM-F000085_seg001\" \"GadMARCM-F000071_seg001\" #> [19] \"FruMARCM-M000115_seg001\" \"GadMARCM-F000442_seg002\""},{"path":"https://natverse.org/nat.nblast/reference/plot3d.hclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods to identify and plot groups of neurons cut from an hclust object — plot3d.hclust","title":"Methods to identify and plot groups of neurons cut from an hclust object — plot3d.hclust","text":"plot3d.hclust uses plot3d plot neurons   group, cut hclust object, colour.","code":""},{"path":"https://natverse.org/nat.nblast/reference/plot3d.hclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods to identify and plot groups of neurons cut from an hclust object — plot3d.hclust","text":"","code":"# S3 method for class 'hclust' plot3d(   x,   k = NULL,   h = NULL,   groups = NULL,   col = rainbow,   colour.selected = FALSE,   ... )"},{"path":"https://natverse.org/nat.nblast/reference/plot3d.hclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods to identify and plot groups of neurons cut from an hclust object — plot3d.hclust","text":"x hclust object generated nhclust. k number clusters cut hclust object. h height cut hclust object. groups numeric vector groups plot. col colours groups (directly specified function). colour.selected set TRUE colour palette applies displayed cluster groups (default FALSE). ... additional arguments plot3d","code":""},{"path":"https://natverse.org/nat.nblast/reference/plot3d.hclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods to identify and plot groups of neurons cut from an hclust object — plot3d.hclust","text":"list rgl IDs plotted objects (see   plot3d).","code":""},{"path":"https://natverse.org/nat.nblast/reference/plot3d.hclust.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Methods to identify and plot groups of neurons cut from an hclust object — plot3d.hclust","text":"Note colours order dendrogram assigned   colour_clusters.","code":""},{"path":[]},{"path":"https://natverse.org/nat.nblast/reference/plot3d.hclust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods to identify and plot groups of neurons cut from an hclust object — plot3d.hclust","text":"","code":"# 20 Kenyon cells data(kcs20, package='nat') # calculate mean, normalised NBLAST scores kcs20.aba=nblast_allbyall(kcs20) kcs20.hc=nhclust(scoremat = kcs20.aba) #> The \"ward\" method has been renamed to \"ward.D\"; note new \"ward.D2\" # plot the resultant dendrogram plot(kcs20.hc)   # now plot the neurons in 3D coloured by cluster group # note that specifying db explicitly could be avoided by use of the # \\code{nat.default.neuronlist} option. plot3d(kcs20.hc, k=3, db=kcs20)  # only plot first two groups # (will plot in same colours as when all groups are plotted) plot3d(kcs20.hc, k=3, db=kcs20, groups=1:2) # only plot first two groups # (will be coloured with a two-tone palette) plot3d(kcs20.hc, k=3, db=kcs20, groups=1:2, colour.selected=TRUE)"},{"path":"https://natverse.org/nat.nblast/reference/show_similarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Display two neurons with segments in the query coloured by similarity — show_similarity","title":"Display two neurons with segments in the query coloured by similarity — show_similarity","text":"default, query neuron drawn segments shaded red blue, red indicating poor match target segments, blue good match.","code":""},{"path":"https://natverse.org/nat.nblast/reference/show_similarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display two neurons with segments in the query coloured by similarity — show_similarity","text":"","code":"show_similarity(   query,   target,   smat = NULL,   cols = colorRampPalette(c(\"red\", \"yellow\", \"cyan\", \"navy\")),   col = \"black\",   AbsoluteScale = FALSE,   PlotVectors = TRUE,   ... )"},{"path":"https://natverse.org/nat.nblast/reference/show_similarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display two neurons with segments in the query coloured by similarity — show_similarity","text":"query neuron compare colour. target neuron compare . smat score matrix (NULL, defaults smat.fcwb). cols function use colour segments (e.g. heat.colors). col colour draw target neuron. AbsoluteScale logical indicating whether colours calculated based minimum maximum similarities neuron (AbsoluteScale = FALSE) minimum maximum possible neurons. PlotVectors logical indicating whether vectors dotprops representation plotted. FALSE, points plotted. ... extra arguments pass plot3d.","code":""},{"path":"https://natverse.org/nat.nblast/reference/show_similarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Display two neurons with segments in the query coloured by similarity — show_similarity","text":"show_similarity called side effect drawing   plot; vector object IDs returned.","code":""},{"path":[]},{"path":"https://natverse.org/nat.nblast/reference/show_similarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display two neurons with segments in the query coloured by similarity — show_similarity","text":"","code":"if (FALSE) { # \\dontrun{ library(nat)  # Pull out gamma and alpha-beta neurons gamma_neurons <- subset(kcs20, type=='gamma') ab_neurons <- subset(kcs20, type=='ab')  # Compare two alpha-beta neurons with similar branching, but dissimilar arborisation clear3d() show_similarity(ab_neurons[[1]], ab_neurons[[2]])  # Compare an alpha-beta and a gamma neuron with some similarities and differences clear3d() show_similarity(ab_neurons[[1]], gamma_neurons[[3]]) } # }"},{"path":"https://natverse.org/nat.nblast/reference/smat.fcwb.html","id":null,"dir":"Reference","previous_headings":"","what":"Scoring matrices for neuron similarities in FCWB template brain — smat.fcwb","title":"Scoring matrices for neuron similarities in FCWB template brain — smat.fcwb","text":"Scoring matrices quantify log2 odds ratio segment pair given distance absolute dot product come pair neurons type, rather unrelated neurons.","code":""},{"path":"https://natverse.org/nat.nblast/reference/smat.fcwb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Scoring matrices for neuron similarities in FCWB template brain — smat.fcwb","text":"scoring matrices generated using pairs 150 DL2 antennal lobe projection neurons FlyCircuit dataset 5000 random pairs dataset. smat.fcwb trained using nearest-neighbour distance tangent vector defined first eigen vector k=5 nearest neighbours. smat_alpha.fcwb defined smat.fcwb weighted factor alpha defined (l1-l2)/(l1+l2+l3) l1,l2,l3 three eigen values. work flycircuit dataset carried using smat.fcwb scoring matrix although smat_alpha.fcwb matrix emphasises significance matches linear regions neuron (axons) may advantages.","code":""},{"path":"https://natverse.org/nat.nblast/reference/sparse_score_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a subset of a square score matrix to a sparse representation — sparse_score_mat","title":"Convert a subset of a square score matrix to a sparse representation — sparse_score_mat","text":"can useful storing raw forwards reverse NBLAST scores set neurons without store uncomputed elements full score matrix.","code":""},{"path":"https://natverse.org/nat.nblast/reference/sparse_score_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a subset of a square score matrix to a sparse representation — sparse_score_mat","text":"","code":"sparse_score_mat(neuron_names, dense_matrix)"},{"path":"https://natverse.org/nat.nblast/reference/sparse_score_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a subset of a square score matrix to a sparse representation — sparse_score_mat","text":"neuron_names character vector neuron names save scores . dense_matrix original, dense version full score matrix.","code":""},{"path":"https://natverse.org/nat.nblast/reference/sparse_score_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a subset of a square score matrix to a sparse representation — sparse_score_mat","text":"spare matrix, compressed, column-oriented form, R object   inheriting CsparseMatrix-class   generalMatrix-class.","code":""},{"path":[]},{"path":"https://natverse.org/nat.nblast/reference/sparse_score_mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a subset of a square score matrix to a sparse representation — sparse_score_mat","text":"","code":"data(kcs20, package = \"nat\") scores=nblast_allbyall(kcs20) scores.3.sparse=sparse_score_mat(names(kcs20)[3], scores) scores.3.sparse #>  [1] 3234.54125 -935.33772 3382.60124 -515.53376  125.68989  244.92594 #>  [7] 4259.57193  480.41458 2048.01759 2068.51808 1278.68688 1359.49507 #> [13]  -15.28677 3403.75462 -313.24728   73.74186 3277.87783 3122.69555 #> [19] 2656.70773 1487.45673  301.63902  360.64137   23.53454 2849.13647 #> [25]  309.92651 4043.17656 1962.12743 4202.62578   91.73056 4567.08113 #> [31] 1259.18024 4703.75189 1075.50543 4726.53035   62.48739 4760.69804 #> [37] 2889.29188 4965.70417 -410.27503 5159.32108 -377.93391 5204.87800 #> [43] 2751.04667 5227.65646 2847.10004 5204.87800 1635.40240 5478.21951 #> [49] 1731.55066 5512.38720 -514.09460 5637.66873 -204.79399 5432.66259 #> [55] -393.66139 5762.95025 1968.02090 5580.72258 #> Class 'spam' (32-bit) # can also add additional submatrices fill_in_sparse_score_mat(scores.3.sparse,scores[3:6,3:4]) #>  [1] 3234.54125 -935.33772 3382.60124 -515.53376  125.68989  244.92594 #>  [7] 4259.57193  480.41458 2048.01759 2068.51808 1278.68688 1359.49507 #> [13]  -15.28677 3403.75462 -313.24728   73.74186 3277.87783 3122.69555 #> [19] 2656.70773 1487.45673  301.63902  360.64137   23.53454 2849.13647 #> [25]  309.92651 4043.17656 1962.12743  254.75164 4202.62578   91.73056 #> [31] -520.25810 4567.08113 1259.18024 4703.75189 1075.50543 4726.53035 #> [37]   62.48739 4760.69804 2889.29188 4965.70417 -410.27503 5159.32108 #> [43] -377.93391 5204.87800 2751.04667 5227.65646 2847.10004 5204.87800 #> [49] 1635.40240 5478.21951 1731.55066 5512.38720 -514.09460 5637.66873 #> [55] -204.79399 5432.66259 -393.66139 5762.95025 1968.02090 5580.72258 #> Class 'spam' (32-bit)"},{"path":"https://natverse.org/nat.nblast/reference/sub_dist_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert (a subset of) a raw score matrix to a distance matrix — sub_dist_mat","title":"Convert (a subset of) a raw score matrix to a distance matrix — sub_dist_mat","text":"function can convert raw score matrix returned   nblast square distance matrix dist object. can   used file-backed matrices well regular R matrices resident   memory.","code":""},{"path":"https://natverse.org/nat.nblast/reference/sub_dist_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert (a subset of) a raw score matrix to a distance matrix — sub_dist_mat","text":"","code":"sub_dist_mat(   neuron_names,   scoremat = NULL,   form = c(\"matrix\", \"dist\"),   maxneurons = NA )"},{"path":"https://natverse.org/nat.nblast/reference/sub_dist_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert (a subset of) a raw score matrix to a distance matrix — sub_dist_mat","text":"neuron_names character vector neuron identifiers. scoremat score matrix use (see sub_score_mat details default). form type object return. maxneurons set sensible value avoid loading huge (order N^2) distances directly memory.","code":""},{"path":"https://natverse.org/nat.nblast/reference/sub_dist_mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert (a subset of) a raw score matrix to a distance matrix — sub_dist_mat","text":"return object class matrix dist (determined form   argument), corresponding subset distance matrix","code":""},{"path":"https://natverse.org/nat.nblast/reference/sub_dist_mat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert (a subset of) a raw score matrix to a distance matrix — sub_dist_mat","text":"Note neuron_names missing rownames   scoremat used .e. every neuron scoremat   used.","code":""},{"path":[]},{"path":"https://natverse.org/nat.nblast/reference/sub_score_mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Return scores (or distances) for given query and target neurons — sub_score_mat","title":"Return scores (or distances) for given query and target neurons — sub_score_mat","text":"Scores can either returned raw numbers, normalised self-hit score 1, average normalised scores forwards & reverse directions (.e. |query->target| + |target->query| / 2). Distances returned either 1 - normscore forwards direction, 1 - normscorebar, normscorebar normscore averaged across directions.","code":""},{"path":"https://natverse.org/nat.nblast/reference/sub_score_mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return scores (or distances) for given query and target neurons — sub_score_mat","text":"","code":"sub_score_mat(   query,   target,   scoremat = NULL,   distance = FALSE,   normalisation = c(\"raw\", \"normalised\", \"mean\") )"},{"path":"https://natverse.org/nat.nblast/reference/sub_score_mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return scores (or distances) for given query and target neurons — sub_score_mat","text":"query, target character vectors neuron identifiers. scoremat matrix, ff matrix, bigmatrix character vector specifying name ff matrix containing score matrix. distance logical indicating whether return distances scores. normalisation type normalisation procedure carried , selected  'raw', 'normalised' 'mean' (.e. average normalised scores directions). distance=TRUE raw.","code":""},{"path":[]},{"path":"https://natverse.org/nat.nblast/reference/subset.hclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the labels of items in 1 or more groups cut from hclust object — subset.hclust","title":"Return the labels of items in 1 or more groups cut from hclust object — subset.hclust","text":"Return labels items 1 groups cut hclust object","code":""},{"path":"https://natverse.org/nat.nblast/reference/subset.hclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the labels of items in 1 or more groups cut from hclust object — subset.hclust","text":"","code":"# S3 method for class 'hclust' subset(x, k = NULL, h = NULL, groups = NULL, ...)"},{"path":"https://natverse.org/nat.nblast/reference/subset.hclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return the labels of items in 1 or more groups cut from hclust object — subset.hclust","text":"x tree like object k integer scalar desired number groups h numeric scalar height tree cut groups vector groups inspect. ... Additional parameters passed methods","code":""},{"path":"https://natverse.org/nat.nblast/reference/subset.hclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return the labels of items in 1 or more groups cut from hclust object — subset.hclust","text":"character vector labels selected items","code":""},{"path":"https://natverse.org/nat.nblast/reference/subset.hclust.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Return the labels of items in 1 or more groups cut from hclust object — subset.hclust","text":"one h k supplied.","code":""},{"path":"https://natverse.org/nat.nblast/news/index.html","id":"natnblast-168","dir":"Changelog","previous_headings":"","what":"nat.nblast 1.6.8","title":"nat.nblast 1.6.8","text":"docs: add missing package anchors requested CRAN","code":""},{"path":"https://natverse.org/nat.nblast/news/index.html","id":"natnblast-166","dir":"Changelog","previous_headings":"","what":"nat.nblast 1.6.6","title":"nat.nblast 1.6.6","text":"Keep scale factor normalising (#38) Doc fixes","code":""},{"path":"https://natverse.org/nat.nblast/news/index.html","id":"natnblast-164","dir":"Changelog","previous_headings":"","what":"nat.nblast 1.6.4","title":"nat.nblast 1.6.4","text":"pkgdown documentation use development version nat package install_github nat.nblast spelling","code":""},{"path":"https://natverse.org/nat.nblast/news/index.html","id":"natnblast-163","dir":"Changelog","previous_headings":"","what":"nat.nblast 1.6.3","title":"nat.nblast 1.6.3","text":"fixes/examples show_similarity allow score matrices passed first param nhclust (issue warning) change vignette engine rmarkdown","code":""},{"path":"https://natverse.org/nat.nblast/news/index.html","id":"natnblast-162","dir":"Changelog","previous_headings":"","what":"nat.nblast 1.6.2","title":"nat.nblast 1.6.2","text":"CRAN release: 2016-04-26 minor fixes 3.3 add vignette simplify travis setup","code":""},{"path":"https://natverse.org/nat.nblast/news/index.html","id":"natnblast-161","dir":"Changelog","previous_headings":"","what":"nat.nblast 1.6.1","title":"nat.nblast 1.6.1","text":"dev: fix test different normalisation types","code":""},{"path":"https://natverse.org/nat.nblast/news/index.html","id":"natnblast-16","dir":"Changelog","previous_headings":"","what":"nat.nblast 1.6","title":"nat.nblast 1.6","text":"fix handling non-square matrices sub_score_mat minor doc fixes","code":""},{"path":"https://natverse.org/nat.nblast/news/index.html","id":"natnblast-15","dir":"Changelog","previous_headings":"","what":"nat.nblast 1.5","title":"nat.nblast 1.5","text":"CRAN release: 2014-09-19 switch importing nat depending ","code":""},{"path":"https://natverse.org/nat.nblast/news/index.html","id":"natnblast-14","dir":"Changelog","previous_headings":"","what":"nat.nblast 1.4","title":"nat.nblast 1.4","text":"use nabor package, RANN, finding nearest neighbours add functions creating sparse score matrices, using spam package speed extraction diagonal elements -disk score matrices nblast now handles combinations neuron dotprops objects","code":""},{"path":"https://natverse.org/nat.nblast/news/index.html","id":"natnblast-13","dir":"Changelog","previous_headings":"","what":"nat.nblast 1.3","title":"nat.nblast 1.3","text":"functions create scoring matrices; see create_scoringmatrix details. fix: really use nhclust’s distfun argument new nblast_allbyall function add plyr support (gives parallelisation progress bar options)","code":""},{"path":"https://natverse.org/nat.nblast/news/index.html","id":"natnblast-12","dir":"Changelog","previous_headings":"","what":"nat.nblast 1.2","title":"nat.nblast 1.2","text":"add nhclust, plot3d.hclust, subset.hclust help cluster/plot based nblast scores (ported flycircuit package). rename showSimilarity -> show_similarity dev: make sure tests run check() test: update baselines given score matrix changes 1.1","code":""},{"path":"https://natverse.org/nat.nblast/news/index.html","id":"natnblast-11","dir":"Changelog","previous_headings":"","what":"nat.nblast 1.1","title":"nat.nblast 1.1","text":"fix: make smat.fcwb default scoring matrix (rather smat_alpha) nblast’s UseAlpha parameter FALSE (default) smat_alpha.fcwb default UseAlpha=TRUE. rename smat->smat.fcwb smat_alpha->smat_alpha.fcwb make clear defined FCWB template space (though work OK fly template brains absolute physical scale) don’t set options(“nat.nblast.defaultsmat”“), just query . doc: basic package documentations","code":""}]
